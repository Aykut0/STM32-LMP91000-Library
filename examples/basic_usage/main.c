/**
 * @file main.c
 * @brief Example usage of STM32 LMP91000 Library
 * 
 * This example shows how to:
 * 1. Initialize the LMP91000
 * 2. Configure it for electrochemical sensing
 * 3. Read sensor data via ADC
 * 4. Convert to meaningful current values
 * 
 * Hardware connections:
 * - LMP91000 VDD -> 3.3V
 * - LMP91000 GND -> GND
 * - LMP91000 SCL -> I2C1 SCL (with 10k pull-up)
 * - LMP91000 SDA -> I2C1 SDA (with 10k pull-up)
 * - LMP91000 MENB -> GPIOB Pin 0
 * - LMP91000 VOUT -> ADC1 Channel (e.g., PA0)
 */

#include "main.h"
#include "lmp91000.h"
#include <stdio.h>

// Global variables
LMP91000_Handle_t hlmp91000;
ADC_HandleTypeDef hadc1;
I2C_HandleTypeDef hi2c1;
UART_HandleTypeDef huart2;  // For printf output

// Function prototypes
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_ADC1_Init(void);
static void MX_USART2_UART_Init(void);
void Init_LMP91000(void);
void Read_Sensor_Data(void);

int main(void)
{
    // Initialize HAL
    HAL_Init();
    SystemClock_Config();

    // Initialize peripherals
    MX_GPIO_Init();
    MX_I2C1_Init();
    MX_ADC1_Init();
    MX_USART2_UART_Init();

    // Initialize LMP91000
    Init_LMP91000();

    printf("LMP91000 Example Started!\r\n");

    while (1)
    {
        // Read sensor data every 100ms
        Read_Sensor_Data();
        HAL_Delay(100);
    }
}

void Init_LMP91000(void)
{
    printf("Initializing LMP91000...\r\n");

    // Initialize LMP91000 (MENB connected to GPIOB Pin 0)
    if (LMP91000_Init(&hlmp91000, &hi2c1, GPIOB, GPIO_PIN_0) != LMP91000_OK) {
        printf("ERROR: LMP91000 initialization failed!\r\n");
        Error_Handler();
    }

    printf("LMP91000 initialized successfully!\r\n");

    // Configure TIA - 120k立 gain for typical electrochemical sensors
    if (LMP91000_SetTIA(&hlmp91000, LMP91000_TIA_GAIN_120K, LMP91000_RLOAD_100) != LMP91000_OK) {
        printf("ERROR: TIA configuration failed!\r\n");
        Error_Handler();
    }

    // Set internal 2.5V reference with 50% zero (1.25V bias)
    if (LMP91000_SetReference(&hlmp91000, LMP91000_REF_INTERNAL, LMP91000_ZERO_50PCT) != LMP91000_OK) {
        printf("ERROR: Reference configuration failed!\r\n");
        Error_Handler();
    }

    // No applied bias voltage initially
    if (LMP91000_SetBias(&hlmp91000, LMP91000_BIAS_POSITIVE, LMP91000_BIAS_0PCT) != LMP91000_OK) {
        printf("ERROR: Bias configuration failed!\r\n");
        Error_Handler();
    }

    // Set to 3-lead amperometric mode
    if (LMP91000_SetMode(&hlmp91000, LMP91000_MODE_3LEAD_AMPEROMETRIC) != LMP91000_OK) {
        printf("ERROR: Mode configuration failed!\r\n");
        Error_Handler();
    }

    printf("LMP91000 configured for electrochemical sensing!\r\n");
    printf("Configuration:\r\n");
    printf("- TIA Gain: 120k立\r\n");
    printf("- Load Resistor: 100立\r\n");
    printf("- Reference: Internal 2.5V\r\n");
    printf("- Zero: 50%% (1.25V)\r\n");
    printf("- Mode: 3-lead amperometric\r\n");
    printf("Starting measurements...\r\n\r\n");
}

void Read_Sensor_Data(void)
{
    static uint32_t sample_count = 0;

    // Start ADC conversion
    HAL_ADC_Start(&hadc1);

    // Wait for conversion to complete
    if (HAL_ADC_PollForConversion(&hadc1, 10) == HAL_OK) {
        // Get raw ADC value
        uint32_t adc_raw = HAL_ADC_GetValue(&hadc1);

        // Convert to voltage (assuming 3.3V reference, 12-bit ADC)
        float voltage = adc_raw * 3.3f / 4095.0f;

        // Convert to sensor current
        // Formula: I = (Vout - Vzero) / Rtia
        // With 120k立 TIA and 1.25V zero point
        float current_nA = (voltage - 1.25f) / 120000.0f * 1e9f;

        // Print every 10th sample to avoid flooding
        sample_count++;
        if (sample_count % 10 == 0) {
            printf("Sample %lu: ADC=%lu, Voltage=%.3fV, Current=%.1fnA\r\n",
                   sample_count, adc_raw, voltage, current_nA);
        }
    }
    else {
        printf("ADC conversion timeout!\r\n");
    }

    HAL_ADC_Stop(&hadc1);
}

// Printf redirect for UART output
int _write(int file, char *ptr, int len)
{
    HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY);
    return len;
}

void Error_Handler(void)
{
    __disable_irq();
    while (1) {
        // Error state - could blink LED here
    }
}

// Note: Include your standard STM32 initialization functions here
// (SystemClock_Config, MX_GPIO_Init, MX_I2C1_Init, etc.)
// These are generated by STM32CubeMX and are standard for your specific MCU
